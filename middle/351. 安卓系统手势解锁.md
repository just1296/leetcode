# 351. 安卓系统手势解锁

我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。

给你两个整数，分别为 ​​m 和 n，其中 1 ≤ m ≤ n ≤ 9，那么请你统计一下有多少种解锁手势，是至少需要经过 m 个点，但是最多经过不超过 n 个点的。
 

先来了解下什么是一个有效的安卓解锁手势:

- 每一个解锁手势必须至少经过 m 个点、最多经过 n 个点。
- 解锁手势里不能设置经过重复的点。
- 假如手势中有两个点是顺序经过的，那么这两个点的手势轨迹之间是绝对不能跨过任何未被经过的点。
- 经过点的顺序不同则表示为不同的解锁手势。

![](https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png)

解释:

```
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |
```
无效手势：`4 - 1 - 3 - 6`
连接点 1 和点 3 时经过了未被连接过的 2 号点。

无效手势：`4 - 1 - 9 - 2`
连接点 1 和点 9 时经过了未被连接过的 5 号点。

有效手势：`2 - 4 - 1 - 3 - 6`
连接点 1 和点 3 是有效的，因为虽然它经过了点 2 ，但是点 2 在该手势中之前已经被连过了。

有效手势：`6 - 5 - 4 - 1 - 9 - 2`
连接点 1 和点 9 是有效的，因为虽然它经过了按键 5 ，但是点 5 在该手势中之前已经被连过了。


示例:

```
输入: m = 1，n = 1
输出: 9
```


## 题解
### 方法：回溯
### 合法路径判断
- 1、上下左右移动，马的移动（例如1->8、1->6），起点+终点=奇数，永远合法
- 2、斜方向移动（例如5->1，5->3），不在同一行与同一列，前提是要排除掉对角线移动，永远合法
- 3、对角线移动（例如1->9，3->7），起点+终点=8，必须在条件2之前判断，排除掉特殊情况，此处判断中间位置是否访问即可
- 4、边长移动（例如1->3，1->7），除了条件1、2、3之外剩下的就是边长移动情况，此处判断中间位置是否访问即可

#### 算法

算法适用回溯方法模拟所有可能的 kk 个数字 [1…9][1…9] 的组合，其中 m \leq k \leq nm≤k≤n。在构造递归搜索树的时候，算法会剪枝掉所有不满足规则的方案。

为了计算一个合法手势，算法按照如下步骤进行：

- 选择一个当前仍然未被使用的数字 *i*，这一步通过一个访问数组 *used* 实现，保存所有可用数字。
- 我们需要记录上一个访问的数字 *last*。算法需要检查是否满足以下任一条件：
	- 从 *last* 到 *i* 之间是国际象棋中马的移动，或者 *last* 和 *i* 是同一行或列的相邻元素。这种情况下，两个数字之和应当为奇数。
	- 连接 *last* 和 *i* 的中间元素 *mid* 已经被访问过，比方说 *last* 和 *i* 选择的是对角线上的两点，那么中间点 *mid = 5* 应当已经选过。
	- *last* 和 *i* 是对角线上的相邻元素。

假设上面有一个条件满足，数字 ii 就变成了合法手势的一部分，算法继续枚举下一个数字，知道整个手势图案被生成。最终计数总方案数。

加入没有任一条件符合，算法当前就不会选择数字 ii，回溯然后继续在未使用的数字中搜索可行的数字。

![](https://pic.leetcode-cn.com/6ff3556255ac4f503f4f82273bdfb135d724c1f52c805dcc1f7dead1d526eb72-image.png)


```java
public class Solution {
	private boolean[] used = new boolean[9];
	
	public int numberOfPatterns(int m, int n) {
		int res = 0;
		for (int len = m; len <= n; len++) {
			res += calcPatterns(-1, len);
		}
		return res;
	}
	
	private int calcPatterns(int last, int len) {
		if (len == 0) {
			return 1;
		}
		int sum = 0;
		for (int i = 0; i < 9; i++) {
			if (isValid(last, i)) {
				used[i] = true;
				sum += calcPatterns(i, len - 1);
				used[i] = false;
			}
		}
		return sum;
	}
	
	private boolean isValid(int last, int index) {
		if (used[index]) {
			return false;
		}
		// 图案的第一个点
		if (last == -1) {
			return true;
		}
		// 马字移动或在相同行或列移动
		if ((last + index) % 2 == 1) {
			return true;
		}
		// 索引位于对角线两段，例如（0, 0）和(8, 8)
		int mid = (last + index) / 2;
		if (mid == 4) {
			return used[mid];
		}
		// 相邻的cell，例如（0, 0）和（0, 1）或 (2, 0)和（1, 1）
		if ((last % 3 != index % 3) && (last / 3 != index / 3)) {
			return true;
		}
		return used[mid];
	}
}
```

### 复杂度分析

时间复杂度：*O(n!)*，其中 *n* 是最大手势长度。

算法计算每个手势一次，没有数字在手势中出现两次。时间复杂度和手势中出现的数字成正比，所以可能组合的上界是：

空间复杂度：*O(n)*，其中 *n* 是最大手势长度。

最坏情况下最大迭代深度为 *n*，因此需要 *O(n)* 空间存储栈。

来源：力扣（LeetCode）

链接：[https://leetcode-cn.com/problems/android-unlock-patterns]()

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。